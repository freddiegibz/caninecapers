import { NextResponse } from 'next/server';
import { supabase } from '../../../../src/lib/supabaseClient';
import fs from 'fs';
import path from 'path';

// Helper type for Acuity webhook logging
interface AcuityWebhookLog {
  action?: string | null;
  appointment: {
    id?: string | null;
    datetime?: string | null;
    calendarID?: string | null;
    client?: {
      email?: string | null;
    };
  };
}

// Helper: map Acuity calendar IDs ‚Üí field names
function getFieldName(calendarID: number): string {
  switch (calendarID) {
    case 4783035:
      return 'Central Bark';
    case 6255352:
      return 'Hyde Bark';
    default:
      return 'Central Bark';
  }
}

// Helper: format datetime to ISO string
function formatDate(datetime: string): string {
  const d = new Date(datetime);
  return d.toISOString();
}

export async function POST(request: Request) {
  try {
    // Parse Acuity's form-encoded payload
    const requestBody = await request.text();
    console.log('üìÑ Raw request body:', requestBody);

    // Parse form data manually since URLSearchParams doesn't handle nested brackets well
    const formData: Record<string, string> = {};
    const pairs = requestBody.split('&');
    for (const pair of pairs) {
      const [key, value] = pair.split('=');
      if (key && value) {
        formData[decodeURIComponent(key)] = decodeURIComponent(value);
      }
    }
    console.log('üìÑ Manually parsed form data:', formData);

    // Extract key fields from manually parsed form data
    const action = formData['action'];
    const appointmentId = formData['appointment[id]'];
    const datetime = formData['appointment[datetime]'];
    const calendarId = formData['appointment[calendarID]'];

    // Check for app-generated booking validation
    const source = formData['source'];
    const isAppGenerated = source === 'app' || formData['app_generated'] === 'true';
    console.log('üìÑ Booking source validation:', { source, isAppGenerated });

    // Handle nested client email field - check all possible variations
    let clientEmail = formData['appointment[client][email]'];
    console.log('üìÑ Checking for clientEmail:', { direct: formData['appointment[client][email]'], truncated: formData['client][email'] });

    if (!clientEmail) {
      // Try alternative keys that might be generated by different encoders
      const possibleKeys = ['client][email', 'appointment_client_email', 'client_email'];
      for (const key of possibleKeys) {
        console.log(`üìÑ Checking key "${key}":`, formData[key]);
        if (formData[key]) {
          clientEmail = formData[key];
          console.log(`üìÑ Found email in key "${key}":`, clientEmail);
          break;
        }
      }
    }

    // Last resort: search for any key containing 'email'
    if (!clientEmail) {
      for (const [key, value] of Object.entries(formData)) {
        if (key.includes('email') && value.includes('@')) {
          clientEmail = value;
          console.log(`üìÑ Found email in key "${key}":`, clientEmail);
          break;
        }
      }
    }

    console.log('üìÑ Extracted fields:', { action, appointmentId, datetime, calendarId, clientEmail });

    // Handle non-app-generated bookings gracefully
    if (!isAppGenerated) {
      console.log('‚ÑπÔ∏è Non-app booking detected - logging but not processing:', {
        appointmentId,
        clientEmail,
        source: source || 'unknown'
      });

      // Create payload object for logging only
      const payload: AcuityWebhookLog = {
        action,
        appointment: {
          id: appointmentId,
          datetime,
          calendarID: calendarId,
          client: {
            email: clientEmail
          }
        }
      };

      // Save to file for audit purposes but don't create session
      try {
        const logDir = '/tmp';
        const filePath = path.join(logDir, `acuity_external_booking_${Date.now()}.json`);
        fs.writeFileSync(filePath, JSON.stringify({
          ...payload,
          source: source || 'external',
          processed: false,
          reason: 'Not app-generated booking'
        }, null, 2));
        console.log(`üìÑ Logged external booking to ${filePath}`);
      } catch (fileErr) {
        console.error('‚ùå Error logging external booking:', fileErr);
      }

      // Return success but don't process the session
      return NextResponse.json({
        message: 'External booking logged',
        processed: false
      }, { status: 200 });
    }

    // Create payload object for logging (app-generated bookings only)
    const payload: AcuityWebhookLog = {
      action,
      appointment: {
        id: appointmentId,
        datetime,
        calendarID: calendarId,
        client: {
          email: clientEmail
        }
      }
    };

    // Log the full incoming payload for debugging
    console.log('üîó Acuity Webhook Received:', JSON.stringify(payload, null, 2));

    // --- LOG PAYLOAD TO /tmp ---
    try {
      const logDir = '/tmp';
      const filePath = path.join(logDir, `acuity_payload_${Date.now()}.json`);
      fs.writeFileSync(filePath, JSON.stringify(payload, null, 2));
      console.log(`üìÑ Saved payload to ${filePath}`);
    } catch (fileErr) {
      console.error('‚ùå Error writing payload file:', fileErr);
    }

    // Validate required fields
    if (!appointmentId || !datetime || !calendarId || !clientEmail) {
      console.error('‚ùå Missing required fields:', { appointmentId, datetime, calendarId, clientEmail });
      // Always return 200 OK to Acuity, even on validation errors
      return NextResponse.json({ message: 'OK' }, { status: 200 });
    }

    // Parse and validate calendar ID
    const calendarNum = parseInt(calendarId, 10);
    if (isNaN(calendarNum)) {
      console.error('‚ùå Invalid calendar ID:', calendarId);
      return NextResponse.json({ message: 'OK' }, { status: 200 });
    }

    // Map fields to sessions table
    const field = getFieldName(calendarNum);
    const date = formatDate(datetime);
    const status = action === 'scheduled' ? 'complete' : 'incomplete';

    // Find user by email
    const { data: user, error: userErr } = await supabase
      .from('users')
      .select('id')
      .eq('email', clientEmail)
      .maybeSingle();

    if (userErr) {
      console.error('‚ùå User lookup error:', userErr);
      // Continue processing even if user lookup fails
    }

    const user_id = user?.id ?? null;

    // Handle idempotency: if user exists, check for incomplete session to complete
    let sessionError = null;

    if (user_id) {
      // First, check if there's an incomplete session for this user
      const { data: existing, error: existingErr } = await supabase
        .from('sessions')
        .select('id')
        .eq('user_id', user_id)
        .eq('status', 'incomplete')
        .limit(1)
        .maybeSingle();

      if (existingErr) {
        console.error('‚ùå Session lookup error:', existingErr);
      }

      if (existing) {
        // Update existing incomplete session to complete
        const { error } = await supabase
          .from('sessions')
          .update({
            status: 'complete',
            acuity_appointment_id: parseInt(appointmentId, 10),
            date,
            field,
            updated_at: new Date().toISOString(),
          })
          .eq('id', existing.id);
        sessionError = error;
        console.log(`‚úÖ Marked existing session complete for user ${clientEmail}`);
      } else {
        // Insert new completed session
        const { error } = await supabase.from('sessions').insert({
          user_id,
          acuity_appointment_id: parseInt(appointmentId, 10),
          field,
          date,
          status: 'complete',
        });
        sessionError = error;
        console.log(`‚úÖ Created new completed session for user ${clientEmail}`);
      }
    } else {
      // Insert new session for unlinked user
      const { error } = await supabase.from('sessions').insert({
        user_id: null,
        acuity_appointment_id: parseInt(appointmentId, 10),
        field,
        date,
        status: 'complete',
      });
      sessionError = error;
      console.log(`‚úÖ Created new completed session for unlinked user ${clientEmail}`);
    }

    if (sessionError) {
      console.error('‚ùå Error saving session:', sessionError);
    } else {
      console.log('‚úÖ Session processed successfully:', {
        appointmentId,
        clientEmail,
        field,
        date,
        status
      });
    }

    // Always return 200 OK to prevent Acuity retry loops
    return NextResponse.json({ message: 'OK' }, { status: 200 });
  } catch (err) {
    console.error('‚ùå Webhook error:', err);
    return NextResponse.json({ message: 'OK' }, { status: 200 });
  }
}

// Handle GET requests for endpoint health checks
export async function GET() {
  return NextResponse.json({ status: 'ok' }, { status: 200 });
}

export async function PUT() {
  return NextResponse.json({ error: 'Method not allowed' }, { status: 405 });
}

export async function DELETE() {
  return NextResponse.json({ error: 'Method not allowed' }, { status: 405 });
}
