import { NextResponse } from 'next/server';
import { supabase } from '../../../../src/lib/supabaseClient';
import fs from 'fs';
import path from 'path';

// Helper type for Acuity webhook logging
interface AcuityWebhookLog {
  action?: string | null;
  appointment: {
    id?: string | null;
    datetime?: string | null;
    calendarID?: string | null;
    client?: {
      email?: string | null;
    };
  };
}

// Database operation types
interface SessionUpdateData {
  status: 'complete';
  acuity_appointment_id: number;
  updated_at: string;
  date?: string;
  field?: string;
}

interface SessionInsertData {
  user_id: string | null;
  acuity_appointment_id: number;
  status: 'complete';
  source?: string;
  date?: string;
  field?: string;
  client_email?: string | null;
}

// Helper: map Acuity calendar IDs ‚Üí field names
function getFieldName(calendarID: number): string {
  switch (calendarID) {
    case 4783035:
      return 'Central Bark';
    case 6255352:
      return 'Hyde Bark';
    default:
      return 'Central Bark';
  }
}

// Helper: format datetime to ISO string
function formatDate(datetime: string): string {
  const d = new Date(datetime);
  return d.toISOString();
}

// Note: Acuity API types removed - sessions now matched by email, not Session ID

export async function POST(request: Request) {
  try {
    // Parse Acuity's form-encoded payload
    const requestBody = await request.text();
    console.log('üìÑ Raw request body:', requestBody);

    // Parse form data manually since URLSearchParams doesn't handle nested brackets well
    const formData: Record<string, string> = {};
    const pairs = requestBody.split('&');
    for (const pair of pairs) {
      const [key, value] = pair.split('=');
      if (key && value) {
        formData[decodeURIComponent(key)] = decodeURIComponent(value);
      }
    }
    console.log('üìÑ Manually parsed form data:', formData);

    // Extract key fields - handle both nested appointment[...] format (app) and flat format (Acuity direct)
    const action = formData['action'];

    // Try nested format first (app-generated), then flat format (Acuity direct)
    const appointmentId = formData['appointment[id]'] || formData['id'];
    const datetime = formData['appointment[datetime]'] || formData['datetime'];
    const calendarId = formData['appointment[calendarID]'] || formData['calendarID'];

    // Note: Session ID extraction removed - sessions now matched by email address
    
    // Log form fields for debugging (but don't use for matching)
    const formFieldKeys = Object.keys(formData).filter(key => key.includes('forms'));
    console.log('üìã Form field keys found:', formFieldKeys);
    const source = formData['source'];
    const isAppGenerated = source === 'app' || formData['app_generated'] === 'true';
    console.log('üìÑ Booking source validation:', { source, isAppGenerated });

    // Handle client email field - try multiple possible formats
    let clientEmail = formData['appointment[client][email]'] || formData['email'];
    console.log('üìÑ Checking for clientEmail:', {
      nested: formData['appointment[client][email]'],
      flat: formData['email'],
      truncated: formData['client][email']
    });

    if (!clientEmail) {
      // Try alternative keys that might be generated by different encoders
      const possibleKeys = ['client][email', 'appointment_client_email', 'client_email'];
      for (const key of possibleKeys) {
        console.log(`üìÑ Checking key "${key}":`, formData[key]);
        if (formData[key]) {
          clientEmail = formData[key];
          console.log(`üìÑ Found email in key "${key}":`, clientEmail);
          break;
        }
      }
    }

    // Last resort: search for any key containing 'email'
    if (!clientEmail) {
      for (const [key, value] of Object.entries(formData)) {
        if (key.includes('email') && value.includes('@')) {
          clientEmail = value;
          console.log(`üìÑ Found email in key "${key}":`, clientEmail);
          break;
        }
      }
    }

    console.log('üìÑ Extracted fields:', { action, appointmentId, datetime, calendarId, clientEmail });
    console.log('üìÑ Session matching: Using email address for matching sessions');

    // Validate minimum required fields - be flexible for different Acuity webhook events
    if (!appointmentId) {
      console.error('‚ùå Missing appointment ID - cannot process:', { appointmentId });
      return NextResponse.json({ message: 'OK' }, { status: 200 });
    }

    // Log what we have vs what we need
    console.log('üìã Field availability:', {
      hasAppointmentId: !!appointmentId,
      hasDatetime: !!datetime,
      hasCalendarId: !!calendarId,
      hasClientEmail: !!clientEmail
    });

    // Sessions are now matched by email address, not Session ID

    // Parse and validate calendar ID (skip for external bookings with missing data)
    let calendarNum: number | null = null;
    let field = 'Unknown Field';
    let date: string | null = null;

    if (calendarId) {
      calendarNum = parseInt(calendarId, 10);
      if (isNaN(calendarNum)) {
        console.error('‚ùå Invalid calendar ID:', calendarId);
        return NextResponse.json({ message: 'OK' }, { status: 200 });
      }
      field = getFieldName(calendarNum);
    }

    if (datetime) {
      date = formatDate(datetime);
    }

    // Create payload object for logging
    const payload: AcuityWebhookLog = {
      action,
      appointment: {
        id: appointmentId,
        datetime,
        calendarID: calendarId,
        client: {
          email: clientEmail
        }
      }
    };

    // Log the full incoming payload for debugging
    console.log('üîó Acuity Webhook Received:', JSON.stringify(payload, null, 2));

    // --- LOG PAYLOAD TO /tmp ---
    try {
      const logDir = '/tmp';
      const filePath = path.join(logDir, `acuity_payload_${Date.now()}.json`);
      fs.writeFileSync(filePath, JSON.stringify(payload, null, 2));
      console.log(`üìÑ Saved payload to ${filePath}`);
    } catch (fileErr) {
      console.error('‚ùå Error writing payload file:', fileErr);
    }

    // Match sessions by email address (primary method)
    if (!clientEmail) {
      console.log('‚ö†Ô∏è No email address found - cannot match session. Logging booking only.');
      return NextResponse.json({ message: 'OK - no email to match' }, { status: 200 });
    }

    console.log('üéØ Matching session by email address:', clientEmail);

    // Find incomplete session by email (email stored when incomplete session was created)
    const { data: incompleteSession, error: sessionErr } = await supabase
      .from('sessions')
      .select('id, user_id, created_at')
      .eq('status', 'incomplete')
      .eq('client_email', clientEmail.toLowerCase().trim())
      .order('created_at', { ascending: false })
      .limit(1)
      .maybeSingle();

    if (sessionErr) {
      console.error('‚ùå Error fetching incomplete session:', sessionErr);
    }

    if (incompleteSession) {
      console.log(`‚úÖ Found incomplete session ${incompleteSession.id} for email ${clientEmail}`);
      
      const updateData: SessionUpdateData = {
        status: 'complete',
        acuity_appointment_id: parseInt(appointmentId, 10),
        updated_at: new Date().toISOString(),
      };
      
      if (date) updateData.date = date;
      if (field !== 'Unknown Field') updateData.field = field;
      
      const { error: updateErr } = await supabase
        .from('sessions')
        .update(updateData)
        .eq('id', incompleteSession.id);
      
      if (updateErr) {
        console.error('‚ùå Session update error:', updateErr);
      } else {
        console.log(`‚úÖ Updated session ${incompleteSession.id} to complete for email ${clientEmail}`);
        return NextResponse.json({ message: 'OK' }, { status: 200 });
      }
    } else {
      console.log(`‚ö†Ô∏è No incomplete session found for email ${clientEmail} - creating new session`);
    }

    // If no incomplete session found, create new completed session
    // Note: We can't directly query auth.users with regular Supabase client
    // The incomplete session would have had user_id if user was logged in
    // For new sessions without incomplete match, we'll create with user_id = null
    // It can be linked later if needed
    
    console.log('üìù Creating new completed session for email:', clientEmail);
    
    const insertData: SessionInsertData = {
      user_id: null, // Will be null - can be updated later if user account is found
      acuity_appointment_id: parseInt(appointmentId, 10),
      status: 'complete',
      client_email: clientEmail.toLowerCase().trim(),
    };

    if (date) insertData.date = date;
    if (field !== 'Unknown Field') insertData.field = field;

    const { error: insertErr } = await supabase.from('sessions').insert(insertData);
    
    if (insertErr) {
      console.error('‚ùå Error creating session:', insertErr);
    } else {
      console.log(`‚úÖ Created new completed session for email ${clientEmail}`);
    }

    // Always return 200 OK to prevent Acuity retry loops
    return NextResponse.json({ message: 'OK' }, { status: 200 });
  } catch (err) {
    console.error('‚ùå Webhook error:', err);
    return NextResponse.json({ message: 'OK' }, { status: 200 });
  }
}

// Handle GET requests for endpoint health checks
export async function GET() {
  return NextResponse.json({ status: 'ok' }, { status: 200 });
}

export async function PUT() {
  return NextResponse.json({ error: 'Method not allowed' }, { status: 405 });
}

export async function DELETE() {
  return NextResponse.json({ error: 'Method not allowed' }, { status: 405 });
}
